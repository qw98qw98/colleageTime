
# 面向对象三大特征
---
+ 封装
+ 继承
+ 多态

## 封装 Encapsulation
---
可以通过访问修饰符实现对成员的封装.
  + ### 封装成员变量
    + 使用private修饰的成员变量无法被外界看到.
    + 使用Getter和Setter方法进行private成员变量的获取.
    + 一般情况下封装只进行两步.
    + 封装可以提高成员的安全性.
    + Javabean,实体类,封装类,模型类,poto类都是一个意思,**作用是方便传递数据.**
## 继承 Inheritance
---
继承是实现**代码重用**的一种手段.
+ 把*特征*和*行为*抽象到一个公共的类中,称为*父类*,*子类* **继承** *父类*就可以得到父亲的特征和行为.
+ 子类继承父类时使用关键字**extends**实现.
+ 被*Private*修饰符修饰的*父类成员*不可以被*子类*继承.*子类*使用*extends*只能继承到父类**非私有**的成员.
+ 每个*子类*都只能用有一个*直接父类*,这样的**继承模式**被称为**单继承**,Java的类继承使用**单继承模式**,C++和Python支持多继承.他们都**支持多层继承**.
+ Java不支持环形继承
+ 高内聚低耦合是软件设计最终的目的,而继承会使代码产生关系,形成耦合.
+ #### **特殊地,所有的java类和数组都隐式地继承Java.lang下的Object类.即Object类是所有JAVA类的根基类**
### 方法的重写
+ 重写方法之后会提示@Override注解,注解告诉虚拟机和编译器方法已经重写或被复写.
  1. 方法存在于继承关系的子类中.
  2. 子类重写父类的方法体.
     + 子类的访问修饰符必须大于等于父类的.
     + 返回值类型一致
     + 方法名一致
     + 参数列表一致
     + 异常小于等于父类的
### Super指针
super指针指向父类,如果类存在父类，使用super可以调用父类的非私有成员.
+ 父类的构造方法不会继承给子类
+ 不存在super.super的调用方法.
+ 在构造器中,使用super(*args)可以显式地调用父类的构造方法来构造**本类**从而实现代码的复用.
+ **子类默认会调用父类的*无参构造器***.
+ 必须用在子类构造的**首行**,跟this调用构造器的方法不能一起使用.不能调用2个以上的Super构造器.
---
- ## 拓展:设计模式
> ### *单例模式*
> 在**特定的场景**下,程序中**多次获取**某类的对象,得到的是一个**唯一**的对象.
> ### 构造方法
> 单例模式三步:
> 1.私有化构造方法(此时就不能通过new+构造方法来创建对象了.)
> 2.私有化本类的静态对象.(创建一个唯一的对象)
> 3.为**唯一对象**提供**公共访问的方法**.(只有*Getter*没有*Setter*,即*只读* )
> ### 构建方式
> 通常单例模式在Java语言中，有两种构建方式：
> + 懒汉方式.
>       指全局的单例实例在**第一次被使用时**构建.
> + 饿汉方式.
>       指全局的单例实例在**类装载**时构建. 
> 区别什么时间创立对象以及对象的生存周期.目前的懒汉式在多线程下并不安全.


### QA:代码块 构造器的执行顺序问题
> **Q**:与构造器一起加载,谁先执行?若类继承了父类,怎么执行？若存在祖父类?怎么执行?从根节点到本类的顺序到底是怎样的？
> **A**:先静态,后非静态,先父类,后子类,先代码块,后构造器,子类对象创建优先调用父类的一些东西.

# 多态 Polymorphism
---
*父类类型的变量*具体指向那个类型的值,在**编译**的时候是不确定的;
由这个*父类类型的变量*发起的**方法的调用**在**编译**的时候也是不确定的.
*接口*的使用就是典型的多态,多态可以帮助人类设计出高内聚,低耦合的软件系统,是**重点**.
#### 变量类型
+ ##### *编译时类型*
  *编译时类型*由**声明变量的类型**决定.
+ ##### *运行时类型*
  *运行时类型*由**给这个变量赋值的对象的类型**决定.

例:
~~~java
public class Animal{
    public void eat(){
        System.out.println("I an abstract");
    }
}   
class Dog extends Animal{
    @Override
    public void eat(){
        System.out.println("I eat meat!");
    }
    public void run(){//父类没有本方法
        System.out.println("I can run!");
    }
    public static void main(String[] args) {
        Animal dog=new Dog();//向上转型
        dog.eat();
        dog.run();//编译错误,行为被限制. 
        ((Dog) dog).run();//向下转型
    }
}
~~~
#### 向上转型与向下转型
+ ##### *向上转型*
  **向上转型限制了对象的行为.**
  + *向上转型*指**把子类赋给父类类型**.
  + *子类*可以用父类方法,**若被重写则调用重写后方法**.
  + *子类***不能用父类没有的方法**,就是子类写了也不行.
+ ##### *向下转型*
  + 被*向上转型*的对象可以通过*强制类型转换*的方法*向下转型*.
  + *向下转型*不可以随意转换.通常用*instanceof*先判断类型再调用方法.
    + *instanceOf* **运算符**:判断某对象是否是某类型的实例.
##关联
指一个类的成员变量里有另一个类,此时两类关联了.
